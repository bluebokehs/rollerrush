<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<!--<div id="info">Description</div>-->
		<script src="js/three.js"></script>
		<script src="js/cannon.js"></script>
		<script src="js/main.js"></script>
		<script>
			let speed1 = [0, 0, 0, 0];
			let speed2 = [0, 0, 0, 0];
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			
			// orthographic camera
			//const theHeight = 10 * (window.innerHeight / window.innerWidth);
			//const camera = new THREE.OrthographicCamera(-5, 5, theHeight/ 2, theHeight / -2, 0.1, 1000);

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );

			window.addEventListener('resize', function() {
				var width = window.innerWidth;
				var height = window.innerHeight;
				renderer.setSize(width, height);
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
			});

			// intitialize CannonJS
			const world = new CANNON.World();
			world.gravity.set(0, -10, 0); // gravity pulls things down

			// create the cylinder
			const geometry = new THREE.CylinderGeometry(3, 3, 2, 60);
			const material = new THREE.MeshLambertMaterial( { color: 0x77ccff } );
			const cylinder = new THREE.Mesh( geometry, material );
			cylinder.receiveShadow = true;
			scene.add( cylinder );

			// create physics for cylinder
			const cylinderShape = new CANNON.Cylinder(3, 3, 2, 30);
			const cylinderMaterial = new CANNON.Material();
			const cylinderBody = new CANNON.Body({mass: 0, material: cylinderMaterial})
			cylinderBody.addShape(cylinderShape);
			cylinderBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
			world.add(cylinderBody);

			// create player 1
			const player1Geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
			const player1Material = new THREE.MeshLambertMaterial({color:0xff9999});
			const player1 = new THREE.Mesh(player1Geometry, player1Material);
			player1.castShadow = true;
			player1.position.set(-1, 3, 0);
			scene.add(player1);

			// create physics for player 1
			const shape = new CANNON.Box(
				new CANNON.Vec3(0.25, 0.25, 0.25)
			);
			const body = new CANNON.Body({mass: 2});
			body.addShape(shape);
			body.position.set(-1, 3, 0);
			world.addBody(body);

			// create player 2
			const player2Geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
			const player2Material = new THREE.MeshLambertMaterial({color:0x99ff99});
			const player2 = new THREE.Mesh(player2Geometry, player2Material);
			player2.castShadow = true;
			player2.position.set(1, 3, 0);
			scene.add(player2);

			// create physics for player 2
			const shape2 = new CANNON.Box(
				new CANNON.Vec3(0.25, 0.25, 0.25)
			);
			const body2 = new CANNON.Body({mass: 2});
			body2.addShape(shape2);
			body2.position.set(1, 3, 0);
			world.addBody(body2);

			// create contact material behavior
			const material_ground = new CANNON.ContactMaterial(cylinderMaterial, player1Material, {
				friction: 0.0, restitution: 0.3
			});
			world.addContactMaterial(material_ground);

			// create skybox
			const cubeGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
			const cubeMaterials = [
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_nx.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_px.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_nz.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_ny.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_py.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_pz.jpg"), side: THREE.DoubleSide})
			];
			const cubeMaterial = new THREE.MeshFaceMaterial(cubeMaterials);
			const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
			scene.add(cube);

			// add fog
			//const fog = new THREE.Fog(0x666666, 1000, 5000);
			//scene.add(fog);

			// set up the lights
			const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
			scene.add(ambientLight);

			const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
			directionalLight.position.set(10, 20, 0);
			directionalLight.castShadow = true;
			scene.add(directionalLight);

			// move the camera
			camera.position.z = 5;
			camera.position.y = 3;
			camera.position.x = 0;
			camera.lookAt(0, 0, 0);

			/*const moveBody = function (isBody1, isZ, isNeg) {
				if(isBody1) {
					if(isZ) {
						if(isNeg) {
							body.position.z -= 0.05;
						} else {
							body.position.z += 0.05;
						}
					} else {
						if(isNeg) {
							body.position.x -= 0.05;
						} else {
							body.position.x += 0.05;
						}
					}
				} else {
					if(isZ) {
						if(isNeg) {
							body2.position.z -= 0.05;
						} else {
							body2.position.z += 0.05;
						}
					} else {
						if(isNeg) {
							body2.position.x -= 0.05;
						} else {
							body2.position.x += 0.05;
						}
					}
				}
			}

			const controller = {
				w: {pressed: false, func: moveBody(true, true, true)},
				s: {pressed: false, func: moveBody(true, true, false)},
				a: {pressed: false, func: moveBody(true, false, true)},
				d: {pressed: false, func: moveBody(true, false, false)},
				ArrowUp: {pressed: false, func: moveBody(false, true, true)},
				ArrowDown: {pressed: false, func: moveBody(false, true, false)},
				ArrowLeft: {pressed: false, func: moveBody(false, false, true)},
				ArrowRight: {pressed: false, func: moveBody(false, false, false)},
			}

			document.addEventListener("keydown", (e) => {
				if(controller[e.key]){
					controller[e.key].pressed = true
				}
			})
			document.addEventListener("keyup", (e) => {
				if(controller[e.key]){
					controller[e.key].pressed = false
				}
			})

			const executeMoves = () => {
  				Object.keys(controller).forEach(key=> {
    				controller[key].pressed && controller[key].func()
  				})
			}*/

			document.addEventListener('keyup', (event) => {
				const keyName = event.key;

				// player 1
				if (keyName == 'w') {
					// move player forwards
					speed1[0]+=1.5;
				}
				if (keyName == 's') {
					// move player backwards
					speed1[2]+=1.5;
				}
				if (keyName == 'a') {
					// move player left
					speed1[1]+=1.5;
				}
				if (keyName == 'd') {
					// move player right
					speed1[3]+=1.5;
				}

				// player 2
				if (keyName == 'ArrowUp') {
					// move player forwards
					speed2[0]+=1.5;
				}
				if (keyName == 'ArrowDown') {
					// move player backwards
					speed2[2]+=1.5;
				}
				if (keyName == 'ArrowLeft') {
					// move player left
					speed2[1]+=1.5;
				}
				if (keyName == 'ArrowRight') {
					// move player right
					speed2[3]+=1.5;
				}
			})

			const clock = new THREE.Clock();
			let delta;

			// game logic
			const update = function () {
				//console.log(player1.position.y);
				//executeMoves();

				body.position.z -= (0.01 + (speed1[0] * .01));
				body.position.z += (0.01 + (speed1[2] * .01));
				body.position.x -= (0.01 + (speed1[1] * .01));
				body.position.x += (0.01 + (speed1[3] * .01));

				speed1[0] = Math.max(speed1[0] - 0.01, 0);
				speed1[1] = Math.max(speed1[1] - 0.01, 0);
				speed1[2] = Math.max(speed1[2] - 0.01, 0);
				speed1[3] = Math.max(speed1[3] - 0.01, 0);

				body2.position.z -= (0.01 + (speed2[0] * .01));
				body2.position.z += (0.01 + (speed2[2] * .01));
				body2.position.x -= (0.01 + (speed2[1] * .01));
				body2.position.x += (0.01 + (speed2[3] * .01));

				speed2[0] = Math.max(speed2[0] - 0.01, 0);
				speed2[1] = Math.max(speed2[1] - 0.01, 0);
				speed2[2] = Math.max(speed2[2] - 0.01, 0);
				speed2[3] = Math.max(speed2[3] - 0.01, 0);
				
				if (body.position.y < -3 || body2.position.y < -3) {
					reset();
				}

				// update three.js player 1
				player1.position.set(body.position.x, body.position.y, body.position.z);
				player1.quaternion.set(
					body.quaternion.x,
					body.quaternion.y,
					body.quaternion.z,
					body.quaternion.w
				);

				// update three.js player 2
				player2.position.set(body2.position.x, body2.position.y, body2.position.z);
				player2.quaternion.set(
					body2.quaternion.x,
					body2.quaternion.y,
					body2.quaternion.z,
					body2.quaternion.w
				);
			};

			// draw Scene
			const render = function () {
				renderer.render( scene, camera );
			};

			//resets players to original positions
			const reset = function () {
				body.position.x = -1;
				body.position.y = 3;
				body.position.z = 0;
				body2.position.x = 1;
				body2.position.y = 3;
				body2.position.z = 0;
				speed1[0] = 0;
				speed1[1] = 0;
				speed1[2] = 0;
				speed1[3] = 0;
				speed2[0] = 0;
				speed2[1] = 0;
				speed2[2] = 0;
				speed2[3] = 0;
			}

			// run game loop (update, render, repeat)
			const GameLoop = function () {
				requestAnimationFrame( GameLoop );
				delta = Math.min(clock.getDelta(), 0.1);
				world.step(delta);
				update();
				render();
			};

			GameLoop();
		</script>
	</body>
</html>