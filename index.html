<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/main.js"></script>
		<script type="module">
			import * as CANNON from './js/cannon-es.js'
			//import CannonUtils from './js/cannonUtils.js';
			import { OBJLoader } from 'https://cdn.skypack.dev/three@0.131.1/examples/jsm/loaders/OBJLoader.js';
				
			const scene = new THREE.Scene();

			let cameraFocus = [0, 0, 0];
			let cameraOffset = [0, 0, 0];
			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			
			// orthographic camera
			//const theHeight = 10 * (window.innerHeight / window.innerWidth);
			//const camera = new THREE.OrthographicCamera(-5, 5, theHeight/ 2, theHeight / -2, 0.1, 1000);

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );

			window.addEventListener('resize', function() {
				var width = window.innerWidth;
				var height = window.innerHeight;
				renderer.setSize(width, height);
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
			});

			// intitialize CannonJS
			const world = new CANNON.World();
			world.gravity.set(0, -10, 0); // gravity pulls things down
			
			
			
			
			

			var groundMaterial = new CANNON.Material("groundMaterial");
			// Adjust constraint equation parameters for ground/ground contact
			var ground_ground_cm = new CANNON.ContactMaterial(groundMaterial, groundMaterial, {
				friction: 0.4,
				restitution: 0.3,
				contactEquationStiffness: 1e8,
				contactEquationRelaxation: 3,
				frictionEquationStiffness: 1e8,
				frictionEquationRegularizationTime: 3,
        	});

			// create the cylinder
			/*
			const geometry = new THREE.CylinderGeometry(5, 5, 2, 60);
			const material = new THREE.MeshLambertMaterial( { color: 0x77ccff } );
			const cylinder = new THREE.Mesh( geometry, material );
			cylinder.receiveShadow = true;
			scene.add( cylinder );
			
			// create physics for cylinder
			
			const cylinderShape = new CANNON.Cylinder(5, 5, 2, 60);
			const cylinderBody = new CANNON.Body({mass: 0, material: groundMaterial})
			cylinderBody.addShape(cylinderShape);
			
			world.addBody(cylinderBody);
			*/


			// Create a slippery material (friction coefficient = 0.0)
			var slipperyMaterial = new CANNON.Material("slipperyMaterial");

			// The ContactMaterial defines what happens when two materials meet.
			// In this case we want friction coefficient = 0.0 when the slippery material touches ground.
			var slippery_ground_cm = new CANNON.ContactMaterial(groundMaterial, slipperyMaterial, {
				friction: 0.00018,
				restitution: 0.15,
				contactEquationStiffness: 1e8,
				contactEquationRelaxation: 3
			});

			// We must add the contact materials to the world
			world.addContactMaterial(slippery_ground_cm);

			// We want to have a heavy impact on player collisions
			var slippery_slippery_cm = new CANNON.ContactMaterial(slipperyMaterial, slipperyMaterial, {
				friction: 0.1,
				restitution: 3 // the bounce back of the collision
			});

			// We must add the contact materials to the world
			world.addContactMaterial(slippery_slippery_cm);
            
			
			var levelMesh;
			var levelBody;
			var levelLoaded = false;
			const objLoader = new OBJLoader();
			objLoader.load(
                'maps/level1.obj',
                (object) => {
                    scene.add(object)
					
                    levelMesh = object.children[0]
                    levelMesh.material = new THREE.MeshLambertMaterial( { color: 0x77ccff } );
					levelMesh.position.x = 0;
					levelMesh.position.y = -3;

					const vertices = levelMesh.geometry.attributes.position.array;
        			const indices = Object.keys(vertices).map(Number);			
					console.log(vertices);
					console.log(indices);
                    const levelShape = new CANNON.Trimesh(vertices, indices);
                    
					console.log(levelShape);

					levelBody = new CANNON.Body({ mass: 0, material: groundMaterial })
                    levelBody.addShape(levelShape)
                    levelBody.position.x = levelMesh.position.x
                    levelBody.position.y = levelMesh.position.y
                    levelBody.position.z = levelMesh.position.z
                    
					world.addBody(levelBody)
					
                    levelLoaded = true
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
                },
                (error) => {
                    console.log('An error happened ' + error)
                }
            )

			/*
			const planeGeometry = new THREE.PlaneGeometry(25, 25)
            const planeMesh = new THREE.Mesh(planeGeometry, groundMaterial)
            planeMesh.position.y = -0.01
            planeMesh.rotateX(-Math.PI / 2)
            planeMesh.receiveShadow = true
            scene.add(planeMesh)
            const planeShape = new CANNON.Plane()
            const planeBody = new CANNON.Body({ mass: 0 })
            planeBody.addShape(planeShape)
            planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
            world.addBody(planeBody)
			*/

			// create player 1
			const player1Geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
			const player1Material = new THREE.MeshLambertMaterial({color:0xff9999});
			const player1 = new THREE.Mesh(player1Geometry, player1Material);
			player1.castShadow = true;
			player1.position.set(-1, 3, 0);
			scene.add(player1);

			// create physics for player 1
			const body = new CANNON.Body({mass: 1, material: slipperyMaterial});
			const sphere1 = new CANNON.Sphere(0.08);
			body.addShape(sphere1, new CANNON.Vec3(0.17, 0.17, 0.17));
			const sphere2 = new CANNON.Sphere(0.08);
			body.addShape(sphere2, new CANNON.Vec3(-0.17, 0.17, 0.17));
			const sphere3 = new CANNON.Sphere(0.08);
			body.addShape(sphere3, new CANNON.Vec3(0.17, -0.17, 0.17));
			const sphere4 = new CANNON.Sphere(0.08);
			body.addShape(sphere4, new CANNON.Vec3(-0.17, -0.17, 0.17));

			const sphere5 = new CANNON.Sphere(0.08);
			body.addShape(sphere5, new CANNON.Vec3(0.17, 0.17, -0.17));
			const sphere6 = new CANNON.Sphere(0.08);
			body.addShape(sphere6, new CANNON.Vec3(-0.17, 0.17, -0.17));
			const sphere7 = new CANNON.Sphere(0.08);
			body.addShape(sphere7, new CANNON.Vec3(0.17, -0.17, -0.17));
			const sphere8 = new CANNON.Sphere(0.08);
			body.addShape(sphere8, new CANNON.Vec3(-0.17, -0.17, -0.17));

			const box1 = new CANNON.Box(
				new CANNON.Vec3(0.25, 0.25, 0.25)
			);
			body.addShape(box1);

			body.position.set(-1, 3, 0);
			

			// create player 2
			const player2Geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
			const player2Material = new THREE.MeshLambertMaterial({color:0x99ff99});
			const player2 = new THREE.Mesh(player2Geometry, player2Material);
			player2.castShadow = true;
			player2.position.set(1, 3, 0);
			scene.add(player2);

			// create physics for player 2
			const body2 = new CANNON.Body({mass: 1, material: slipperyMaterial});
			const sphere2_1 = new CANNON.Sphere(0.08);
			body2.addShape(sphere2_1, new CANNON.Vec3(0.17, 0.17, 0.17));
			const sphere2_2 = new CANNON.Sphere(0.08);
			body2.addShape(sphere2_2, new CANNON.Vec3(-0.17, 0.17, 0.17));
			const sphere2_3 = new CANNON.Sphere(0.08);
			body2.addShape(sphere2_3, new CANNON.Vec3(0.17, -0.17, 0.17));
			const sphere2_4 = new CANNON.Sphere(0.08);
			body2.addShape(sphere2_4, new CANNON.Vec3(-0.17, -0.17, 0.17));

			const sphere2_5 = new CANNON.Sphere(0.08);
			body2.addShape(sphere2_5, new CANNON.Vec3(0.17, 0.17, -0.17));
			const sphere2_6 = new CANNON.Sphere(0.08);
			body2.addShape(sphere2_6, new CANNON.Vec3(-0.17, 0.17, -0.17));
			const sphere2_7 = new CANNON.Sphere(0.08);
			body2.addShape(sphere2_7, new CANNON.Vec3(0.17, -0.17, -0.17));
			const sphere2_8 = new CANNON.Sphere(0.08);
			body2.addShape(sphere2_8, new CANNON.Vec3(-0.17, -0.17, -0.17));


			const box2 = new CANNON.Box(
				new CANNON.Vec3(0.25, 0.25, 0.25)
			);
			body2.addShape(box2);
			
			body2.position.set(1, 3, 0);

			world.addBody(body);
			world.addBody(body2);

			// create skybox
			const cubeGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
			const cubeMaterials = [
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_nx.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_px.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_nz.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_ny.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_py.jpg"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("images/skybox_pz.jpg"), side: THREE.DoubleSide})
			];
			const cubeMaterial = new THREE.MeshFaceMaterial(cubeMaterials);
			const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
			scene.add(cube);

			// add fog
			//const fog = new THREE.Fog(0x666666, 1000, 5000);
			//scene.add(fog);

			// set up the lights
			const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
			scene.add(ambientLight);

			const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
			directionalLight.position.set(10, 20, 0);
			directionalLight.castShadow = true;
			scene.add(directionalLight);

			// move the camera
			camera.position.z = 5;
			camera.position.y = 8;
			camera.position.x = 0;
			camera.lookAt((body2.position.x + body.position.x)/2, (body2.position.y + body.position.y)/2, (body2.position.z + body.position.z)/2);

			// set camera offset
			cameraOffset[0] = camera.position.x - (body2.position.x + body.position.x)/2;
			cameraOffset[1] = camera.position.y - (body2.position.y + body.position.y)/2;
			cameraOffset[2] = camera.position.z - (body2.position.z + body.position.z)/2;

			document.addEventListener('keyup', (event) => {
				const keyName = event.key;

				// player 1
				if (keyName == 'w') {
					// move player forwards
					// body.applyForce(new CANNON.Vec3(0, 0, -180), body.position);
					body.force = new CANNON.Vec3(body.force.x, body.force.y, body.force.z - 180);
				}
				if (keyName == 's') {
					// move player backwards
					// body.applyForce(new CANNON.Vec3(0, 0, 180), body.position);
					body.force = new CANNON.Vec3(body.force.x, body.force.y, body.force.z + 180);
				}
				if (keyName == 'a') {
					// move player left
					// body.applyForce(new CANNON.Vec3(-180, 0, 0), body.position);
					body.force = new CANNON.Vec3(body.force.x - 180, body.force.y, body.force.z);
				}
				if (keyName == 'd') {
					// move player right
					// body.applyForce(new CANNON.Vec3(180, 0, 0), body.position);
					body.force = new CANNON.Vec3(body.force.x + 180, body.force.y, body.force.z);
				}

				// player 2
				if (keyName == 'ArrowUp') {
					// move player forwards
					// body2.applyForce(new CANNON.Vec3(0, 0, -180), body2.position);
					body2.force = new CANNON.Vec3(body2.force.x, body2.force.y, body2.force.z - 180);
				}
				if (keyName == 'ArrowDown') {
					// move player backwards
					// body2.applyForce(new CANNON.Vec3(0, 0, 180), body2.position);
					body2.force = new CANNON.Vec3(body2.force.x, body2.force.y, body2.force.z + 180);
				}
				if (keyName == 'ArrowLeft') {
					// move player left
					// body2.applyForce(new CANNON.Vec3(-180, 0, 0), body2.position);
					body2.force = new CANNON.Vec3(body2.force.x - 180, body2.force.y, body2.force.z);
				}
				if (keyName == 'ArrowRight') {
					// move player right
					// body2.applyForce(new CANNON.Vec3(180, 0, 0), body2.position);
					body2.force = new CANNON.Vec3(body2.force.x + 180, body2.force.y, body2.force.z);
				}
			})

			const clock = new THREE.Clock();
			let delta;

			// game logic
			const update = function () {
				//console.log(player1.position.y);
				//executeMoves();

				// camera

				cameraFocus = [(body2.position.x + body.position.x)/2, (body2.position.y + body.position.y)/2, (body2.position.z + body.position.z)/2];
				camera.position.set(cameraOffset[0] + cameraFocus[0], cameraOffset[1] + cameraFocus[1], cameraOffset[2] + cameraFocus[2]);
				
				if (body.position.y < -5 || body2.position.y < -5) {
					reset();
				}

				// update three.js player 1
				player1.position.set(body.position.x, body.position.y, body.position.z);
				player1.quaternion.set(
					body.quaternion.x,
					body.quaternion.y,
					body.quaternion.z,
					body.quaternion.w
				);

				// update three.js player 2
				player2.position.set(body2.position.x, body2.position.y, body2.position.z);
				player2.quaternion.set(
					body2.quaternion.x,
					body2.quaternion.y,
					body2.quaternion.z,
					body2.quaternion.w
				);

				if (levelLoaded) {
                    levelMesh.position.set(
                        levelBody.position.x,
                        levelBody.position.y,
                        levelBody.position.z
                    )
                    levelMesh.quaternion.set(
                        levelBody.quaternion.x,
                        levelBody.quaternion.y,
                        levelBody.quaternion.z,
                        levelBody.quaternion.w
                    )
                }
			};

			// draw Scene
			const render = function () {
				renderer.render( scene, camera );
			};

			//resets players to original positions
			const reset = function () {
				body.position.x = -1;
				body.position.y = 3;
				body.position.z = 0;
				body2.position.x = 1;
				body2.position.y = 3;
				body2.position.z = 0;
				body.velocity = new CANNON.Vec3(0, 0, 0);
				body2.velocity = new CANNON.Vec3(0, 0, 0);
			}

			// run game loop (update, render, repeat)
			const GameLoop = function () {
				requestAnimationFrame( GameLoop );
				delta = Math.min(clock.getDelta(), 0.1);
				world.step(delta);
				update();
				render();
			};

			GameLoop();
		</script>
	</body>
</html>